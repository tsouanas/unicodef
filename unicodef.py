#!/usr/bin/env python

import os
import sys
import re
import argparse
from glob import glob

### gencompose
# Local, trimmed, stripped down, abused version of gencompose
# included here for single-file portability.
# For the original, see: https://github.com/Granitosaurus/macos-compose

import json
from collections.abc import MutableMapping
from copy import deepcopy
from typing import Union, Tuple, Callable, Type, Iterable, Dict

def key_nest(keys: Iterable) -> Dict:
    v = None
    for c in keys[::-1]:
        v = {c: v} if v else c
    return v

def object_hook(dict_, func: Callable, types: Union[Tuple[Type], Type] = dict):
    new = deepcopy(dict_)
    if isinstance(dict_, types):  # hook self as well
        new = func(new)
    if not isinstance(new, MutableMapping):
        return new
    for key in new:
        # recursive object_hook for dicts
        if isinstance(new[key], MutableMapping):
            new[key] = object_hook(new[key], func, types)
        # for lists either apply function if type matched or recursive object_hook if dict
        elif isinstance(new[key], (list, tuple)):
            new[key] = type(new[key])(
                object_hook(v, func, types) if
                isinstance(v, MutableMapping) else func(v)
                if isinstance(v, types) else v
                for v in new[key]
            )
        if isinstance(new[key], types):
            new[key] = func(new[key])
    return new

def merge(source, destination):
    if isinstance(destination, str):
        return source
    for k, v in source.items():
        if isinstance(v, dict):
            # get node or create one
            node = destination.setdefault(k, {})
            merge(v, node)
        else:
            destination[k] = v
    return destination

def read_paths(data):
    parsed = {}
    for k, v in data.items():
        parsed = merge(parsed, key_nest(list(k) + [v]))
    return parsed

def data_to_mac_dict(data):
    updated = object_hook(data, lambda value: f'INSERT:{value}', str)
    text = json.dumps(updated, indent=2, ensure_ascii=False)
    repl = lambda value: f'("insertText:", "{value.groups()[0]}");'
    text = re.sub('"INSERT:(.+)",*', repl, text)
    text = re.sub('},*(\n|$)', '};\n', text)
    text = re.sub('": ', '" = ', text)
    return text

### /gencompose

### unicodef

# parser

parser = argparse.ArgumentParser(
        prog='unicodef',
        description='Generate Markdown, XCompose, vim, and macOS dict files.',
        epilog='URL: https://github.com/tsouanas/unicodef',
        )

parser.add_argument('infiles', metavar='INFILE', type=str, nargs='+',
                    help='input files')
parser.add_argument('outdir', metavar='OUTDIR', type=str, nargs=1,
                    help='directory to place output files')
parser.add_argument('-v', '--verbose', action='store_true',
                    help='verbose output')
args = parser.parse_args()

# global

modes = ['macro', 'micro']
book = dict(macro={}, micro={})
chapters = {}
head = "generated by unicodef: https://github.com/tsouanas/unicodef"

# shared

def translate(translator, w):
    return ''.join([ translator(c) for c in list(w) ])

def simple_trans(reps):
    return lambda c: reps[c] if c in reps else c

def error(msg, status=1, die=True):
    print(f'ERROR: {msg}', file=sys.stderr)
    if die:
        sys.exit(status)

def warn(msg):
    print(f'Warning: {msg}', file=sys.stderr)

def info(msg):
    if args.verbose:
        print(msg, file=sys.stderr)


# XCompose

xcompose_k_reps = {
    '`':  '<grave>',
    '~':  '<asciitilde>',
    '!':  '<exclam>',
    '@':  '<at>',
    '#':  '<numbersign>',
    '$':  '<dollar>',
    '%':  '<percent>',
    '^':  '<asciicircum>',
    '&':  '<ampersand>',
    '*':  '<asterisk>',
    '(':  '<parenleft>',
    ')':  '<parenright>',
    '-':  '<minus>',
    '_':  '<underscore>',
    '=':  '<equal>',
    '+':  '<plus>',
    '"':  '<quotedbl>',
    "'":  '<apostrophe>',
    '/':  '<slash>',
    '?':  '<question>',
    '\\': '<backslash>',
    '[':  '<bracketleft>',
    ']':  '<bracketright>',
    '{':  '<braceleft>',
    '}':  '<braceright>',
    '|':  '<bar>',
    '<':  '<less>',
    '>':  '<greater>',
    ',':  '<comma>',
    '.':  '<period>',
    ':':  '<colon>',
    ';':  '<semicolon>',
    ' ':  '<space>',
    }

xcompose_v_reps = {
    '"':  '\\"',
    '\\': '\\\\',
    }

def xcompose_trans_k(c):
    if c in xcompose_k_reps:
        return xcompose_k_reps[c]
    elif c.isascii() and c.isalnum():
        return f'<{c}>'
    else:
        warn(f'Ignoring unexpected special character «{c}» on XCompose key.')
        return ''

xcompose_trans_v = simple_trans(xcompose_v_reps)

def xcompose_line(k, v, mode):
    k = translate(xcompose_trans_k, k)
    v = translate(xcompose_trans_v, v)
    if mode == 'micro':
        line = f'<Multi_key>{k} : "{v}"\n'
    else:
        line = f'<Multi_key><Multi_key>{k}<space> : "{v}"\n'
    return line

def xcompose_head(h):
    return f'# {h}\n\n'

# Vim

vim_reps = { '|': '<Bar>' }
vim_trans = simple_trans(vim_reps)

def vim_line(k, v, mode):
    k = translate(vim_trans, k)
    v = translate(vim_trans, v)
    if mode == 'micro':
        line = f'inoremap \\{k} {v}\n'
    else:
        line = f'inoremap \\\\{k} {v}\n'
    return line

def vim_head(h):
    return f'" {h}\n\n'


# Markdown

md_reps = {
    '`': '&#96;',
    '|': '&vert;',
    '<': '&lt;',
    '>': '&gt;',
    }
md_trans = simple_trans(md_reps)

def md_caption(title, level=1):
    return f'''{"#" * level} {title}
| Sequence | Expansion |
| :------- | :-------: |
'''

def md_line(k, v):
    k = translate(md_trans, k)
    v = translate(md_trans, v)
    return f'| <code>{k}</code> | {v} |\n'


# macOS dict

def chapter_pydict(chapter, macosprefix='§'):
    d = {}
    for (k,v) in chapter['micro'].items():
        d[k] = v
    for (k,v) in chapter['macro'].items():
        d[f'{macosprefix}{k} '] = v
    return d

def pydict_macosdict(pydict, macosprefix='§'):
    text = data_to_mac_dict(read_paths(pydict))
    text = f'{{"{macosprefix}" = {text}}}\n'
    text = text.replace('"^" = ', r'"\\^" = ')
    text = text.replace('"~" = ', r'"\\~" = ')
    text = text.replace('"@" = ', r'"\\@" = ')
    text = text.replace('"#" = ', r'"\\#" = ')
    text = text.replace('"$" = ', r'"\\$" = ')
    return text

def macosdict_head(h):
    return f'/* {h} */\n\n'

# Processors

langs = dict(
    xcompose = dict(liner=xcompose_line, header=xcompose_head, ext='.XCompose'),
    vim      = dict(liner=vim_line,      header=vim_head,      ext='.vim'),
    )

def infile_name(infile):
    return infile.split('/')[-1].rstrip('_')

def cf_name(cf):
    return infile_name(cf.name)

def cf_mode(cf):
    return 'micro' if cf.name.split('/')[-1].endswith('_') else 'macro'

def process_cf(cf, outdir):
    """
    Updates book and chapters global dicts by adding this cf's content.
    Also appends to markdown files of cf's chapter and of the book.
    """
    global book
    global chapters
    mode = cf_mode(cf)
    name = cf_name(cf)
    # initialize chapter if new
    if name not in chapters:
        chapters[name] = dict(macro={}, micro={})
    # open chapter and book md files for appending
    with open(f'{outdir}/{name}.md', 'a') as chap_md, \
         open(f'{outdir}/unicodefs.md', 'a') as book_md:
        # append headers to md files
        chap_md.write(md_caption(f'{name} ({mode})', level=1))
        book_md.write(md_caption(f'{name} ({mode})', level=2))
        # process cs lines
        for line_no, line in enumerate(cf, start=1):
            line = line.lstrip()
            if line.startswith('#') or not line.rstrip(): continue
            line = line.strip('\u0020\n')
            try:
                k, v = re.split(' +', line, maxsplit=1)
            except ValueError:
                error(f'Cannot parse line {line_no} of {mode} file {name}:\n{line}\n')
            # clean v from possible comment and whitespace
            v = v.split(' #')[0]
            v = v.strip('\u0020\n')
            # check for redefinitions
            if k in book[mode]:
                detail = f'to the same expansion: {v}' if v == book[mode][k] else f'{book[mode][k]} ↦ {v}'
                warn(f'{mode} sequence «{k}» redefined in {name} ({detail})')
            # update book and chapters
            book[mode][k] = v
            chapters[name][mode][k] = v
            # append content to md files
            chap_md.write(md_line(k, v))
            book_md.write(md_line(k, v))

def process_chapter(chapter, name, outdir):
    """
    Creates and writes .XCompose, .dict, and .vim outfiles.
    """
    # write lang files for chapter
    for (lang, writer) in langs.items():
        liner, ext = writer['liner'], writer['ext']
        lines = []
        for mode in modes:
            lines = lines + [ liner(k,v,mode) for (k,v) in chapter[mode].items() ]
        # write lang chapter
        with open(f'{outdir}/{name}{ext}', 'w') as chapter_lang:
            chapter_lang.write(writer['header'](head))
            chapter_lang.writelines(lines)
    # create macosdict
    with open(f'{outdir}/{name}.dict', 'w') as chapter_macosdict:
        chapter_macosdict.write(macosdict_head(head))
        chapter_macosdict.write(pydict_macosdict(chapter_pydict(chapter)))


# main

def main():

    infiles = args.infiles
    outdir = args.outdir[0]

    for infile in args.infiles:
        if not os.path.exists(infile):
            error(f'{infile} does not exist.')

    # initialize all markdowns
    with open(f'{outdir}/unicodefs.md', 'w') as book_md:
        book_md.write('# unicodefs\n\n')
    for infile in args.infiles:
        chap_md_name = f'{outdir}/{infile_name(infile)}.md'
        if os.path.exists(chap_md_name):
            os.remove(chap_md_name)

    # assertion
    if ('unicodefs' in infiles) or ('_unicodefs' in infiles):
        error(f'You cannot name your input file "unicodefs".')

    # process chaptfiles to create chapters and all markdown files
    for infile in infiles:
        with open(f'{infile}', 'r') as cf:
            info(f"Processing {cf_mode(cf)} defs from {infile}.")
            process_cf(cf, outdir)

    # add book as a chapter called 'unicodefs'
    chapters['unicodefs'] = book

    # process chapters to create output files (except markdown)
    for (name, chapter) in chapters.items():
        process_chapter(chapter, name, outdir)

    # check for micro conflicts
    micro_keys = list(book['micro'].keys())
    micro_keys.sort()
    for k, l in zip(micro_keys, micro_keys[1:]):
        if l.startswith(k):
            error(f'micro conflict: «{k}» conflicts with «{l}»)', die=False)


if __name__ == '__main__':
    main()

